from abc import ABC

import logging
from syntax import LanguageSyntax
from variable import *


class CodeGenImp(ABC):
    """
    Interface for the code generation components.
    """
    def __init__(self):
        self._children = []

    def add_child(self, node):
        self._children.insert(0, node)

    def add_children(self, children):
        self._children.extend(children)

    def get_num_children(self):
        return len(self._children)

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        ...

    @staticmethod
    def indent(s: str, depth: int, terminator: str = ""):
        return "\t" * depth + f"{s}{terminator}\n"


class CodeGenInterfaceNode(CodeGenImp):
    """
    Code generator for the parser interface

    TODO Interface is quite hardcoded, requires a refinement step.
    """
    def __init__(self, package_name: str, class_name: str, function_name: str, parsers: dict):
        super().__init__()
        self.package_name = package_name
        self.class_name = class_name
        self.function_name = function_name
        self.parsers = parsers

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        file.content += self.indent(syntax.generate_comment("Generated by the proto-to-bq Proto compiler plugin.  DO NOT EDIT!"), depth)
        file.content += self.indent(f"package {self.package_name};", depth)

        # BigQuery imports
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_import(module="com.google.api.services.bigquery.model", dependency="*"), depth)

        # Java imports
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_import(module="java.util", dependency="LinkedList"), depth)
        file.content += self.indent("", depth)

        obj = Variable("obj", "byte[]")
        file.content += self.indent(syntax.generate_class(self.class_name, abstract=True), depth=depth)

        # Generate abstract function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name=self.function_name, return_type="LinkedList<TableRow>", params=[obj], exceptions=["exception"], abstract=True), depth + 1)

        # Generate table name extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_big_query_table_name", return_type="String", params=[], abstract=True), depth + 1)

        # Generate table description extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_big_query_table_description", return_type="String", params=[], abstract=True), depth + 1)

        # Generate partition field extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_partitioning", return_type="TimePartitioning", params=[], abstract=True), depth + 1)

        # Generate cluster fields extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_clustering", return_type="Clustering", params=[], abstract=True), depth + 1)

        # Schema extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_big_query_table_schema", return_type="TableSchema", params=[], abstract=True), depth + 1)

        # Generate repository function
        # FUTURE: By far not the most elegant approach, but I required a way to fetch parsers given their name.
        file.content += self.indent("", depth)
        proto_type = Variable("proto_type", "String")
        file.content += self.indent(syntax.generate_function_header(name="get_parser_for_type", return_type=self.class_name, params=[proto_type], exceptions=["exception"], static=True), terminator=syntax.block_start_delimiter(), depth=depth + 1)
        file.content += self.indent(f"switch({syntax.to_variable_name(proto_type.get())}) {{", depth + 2)

        for type, parser in self.parsers.items():
            file.content += self.indent(f'case {syntax.format_constant_value(type)}:', depth + 3)
            file.content += self.indent(f'return new {parser}();', depth + 4)

        file.content += self.indent(f'default:', depth + 3)
        file.content += self.indent(syntax.generate_exception(exception_type="Exception", message=f'Parser for type \'" + {syntax.to_variable_name(proto_type.format_value(syntax))} + "\' not registered.'), depth + 4)
        file.content += self.indent("}", depth + 2)
        file.content += self.indent("}", depth + 1)

        file.content += self.indent("}", depth)


class CodeGenClassNode(CodeGenImp):
    """
    Code generator for the Parser class.
    """
    def __init__(self, class_name: str, base_class: str, field_type: MessageFieldType):
        super().__init__()
        self.class_name = class_name
        self.field_type = field_type
        self.base_class = base_class

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        file.content += self.indent(syntax.generate_comment("Generated by the proto-to-bq Proto compiler plugin.  DO NOT EDIT!"), depth)
        file.content += self.indent(f"package {self.field_type.package};", depth)

        # BigQuery imports
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_import(module="com.google.api.services.bigquery.model", dependency="*"), depth)

        # Java imports
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_import(module="java.util", dependency="LinkedList"), depth)
        file.content += self.indent(syntax.generate_import(module="java.util", dependency="List"), depth)
        file.content += self.indent(syntax.generate_import(module="java.util", dependency="Arrays"), depth)
        file.content += self.indent(syntax.generate_import(module="org.joda.time", dependency="Instant"), depth)
        file.content += self.indent("", depth)

        file.content += self.indent(syntax.generate_class(self.class_name, parent_classes=[self.base_class], final=True), terminator=syntax.block_start_delimiter(), depth=depth)

        for child in self._children:
            child.gen_code(syntax, file, element, root_var, depth + 1, type_map)

        # Generate table name extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_big_query_table_name", return_type="String", params=[]), terminator=syntax.block_start_delimiter(), depth=depth + 1)
        file.content += self.indent(syntax.generate_return(StaticValue(self.field_type.table_name)), terminator=syntax.terminate_statement_delimiter(), depth=depth + 2)
        file.content += self.indent(syntax.block_end_delimiter(), depth + 1)

        # Generate table description extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_big_query_table_description", return_type="String", params=[]), terminator=syntax.block_start_delimiter(), depth=depth + 1)
        file.content += self.indent(syntax.generate_return(StaticValue(self.field_type.table_description)), terminator=syntax.terminate_statement_delimiter(), depth=depth + 2)
        file.content += self.indent(syntax.block_end_delimiter(), depth + 1)

        # Generate partition field extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_partitioning", return_type="TimePartitioning", params=[]), terminator=syntax.block_start_delimiter(), depth=depth + 1)

        # https://www.javadoc.io/doc/com.google.apis/google-api-services-bigquery/v2-rev20181221-1.28.0/com/google/api/services/bigquery/model/TimePartitioning.html
        if self.field_type.time_partitioning:
            # Construct the time partitioning object
            time_partitioning = Variable("time_partitioning", "TimePartitioning")
            time_partitioning.push_invocation(Setter("field", params=[StaticValue(self.field_type.partition_field)]))
            time_partitioning.push_invocation(Setter("expiration_ms", params=[StaticValue(self.field_type.partitioning_expiration)])) # TODO Fix python _not_ explicitly supporting long values

            # Declare and return the time partitioning object
            file.content += self.indent(syntax.declare_variable(time_partitioning), depth=depth+2)
            file.content += self.indent(syntax.generate_return(time_partitioning), terminator=syntax.terminate_statement_delimiter(), depth=depth+2)
        else:
            file.content += self.indent(syntax.generate_return(StaticValue(None)), terminator=syntax.terminate_statement_delimiter(), depth=depth + 2)
        file.content += self.indent(syntax.block_end_delimiter(), depth + 1)

        # Generate cluster fields extractor function
        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_function_header(name="get_clustering", return_type="Clustering", params=[]), terminator=syntax.block_start_delimiter(), depth=depth + 1)

        # https://www.javadoc.io/doc/com.google.apis/google-api-services-bigquery/v2-rev20181221-1.28.0/com/google/api/services/bigquery/model/Clustering.html
        if len(self.field_type.cluster_fields) > 0:
            # Construct the clustering object
            clustering = Variable("clustering", "Clustering")
            clustering.push_invocation(Setter("Fields", params=[StaticValue(self.field_type.cluster_fields)]))

            file.content += self.indent(syntax.declare_variable(clustering), depth=depth + 2)
            file.content += self.indent(syntax.generate_return(clustering), terminator=syntax.terminate_statement_delimiter(), depth=depth + 2)
        else:
            file.content += self.indent(syntax.generate_return(StaticValue(None)), terminator=syntax.terminate_statement_delimiter(), depth=depth + 2)
        file.content += self.indent(syntax.block_end_delimiter(), depth + 1)

        file.content += self.indent(syntax.block_end_delimiter(), depth)


class CodeGenSchemaFunctionNode(CodeGenImp):
    """
    Code generation for schema extraction

    FUTURE: Node currently does not adhere the code generation node approach. Might need conversion in the future.
    """
    def __init__(self, field_type: MessageFieldType, bq_type_map: dict):
        super().__init__()
        self.field_type = field_type
        self.bq_type_map = bq_type_map

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):

        file.content += self.indent(f"public TableSchema {syntax.underscore_to_camelcase('get_big_query_table_schema')}() {{", depth)

        # Generate return
        file.content += self.indent(f'return new TableSchema().setFields(Arrays.asList(', depth + 1)
        self._codegen_schema(syntax, file, self.field_type, depth + 2)
        file.content += self.indent('));', depth + 1)

        file.content += self.indent("}", depth)

    def _codegen_schema_field(self, syntax: LanguageSyntax, file, field: Field, depth: int):
        if field.is_batch_field:
            # Batch fields should be skipped, by immediately fetching the next level
            return self._codegen_schema(syntax, file, field.field_type_value, depth)

        file.content += self.indent(f'new TableFieldSchema()', depth)
        file.content += self.indent(f'.setName({Variable.format_constant_value(field.get_bigquery_field_name())})', depth + 1)

        # FUTURE: Enhance logic to represent timestamps
        file.content += self.indent(f'.setType({Variable.format_constant_value(self.bq_type_map[field.field_type] if not field.is_timestamp else "TIMESTAMP")})', depth + 1)

        # FUTURE: Design utility to extract the mode
        file.content += self.indent(f'.setMode("{"REPEATED" if field.is_repeated_field else "REQUIRED" if field.field_required else "NULLABLE"}")', depth + 1)
        file.content += self.indent(f'.setDescription("{field.field_description}")', depth + 1)

        if field.field_type_value is not None:
            file.content += self.indent(f'.setFields(Arrays.asList(', depth + 1)
            self._codegen_schema(syntax, file, field.field_type_value, depth + 2)
            file.content += self.indent(f'))', depth + 1)

    def _codegen_schema(self, syntax: LanguageSyntax, file, field_type: MessageFieldType, depth: int):

        for idx, field in enumerate(field_type.fields):
            self._codegen_schema_field(syntax, file, field, depth)

            if idx < len(field_type.fields) - 1:
                file.content += self.indent(f',', depth)


class CodeGenFunctionNode(CodeGenImp):
    """
    Code generator for the convertToTableRow function.
    """
    def __init__(self, function_name: str, field_type: MessageFieldType):
        super().__init__()
        self.function_name = function_name
        self.field_type = field_type

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        obj = Variable("obj", "byte[]")
        variable = Variable(Variable.to_variable(self.field_type.name), self.field_type.name)
        rows = ListVariable("rows", "LinkedList", "TableRow")

        # Generate function header
        file.content += self.indent(syntax.generate_function_header(name=self.function_name, return_type=rows.type, params=[obj], exceptions=["exception"]), terminator=syntax.block_start_delimiter(), depth=depth)

        # Generate function body
        # Future: extend capabilities of getter function to accept parameters
        file.content += self.indent(syntax.generate_comment("Parse bytes according to Protobuf def"), depth + 1)
        file.content += self.indent(f"{self.field_type.get_class_name()} {variable.get()} = {self.field_type.get_class_name()}.parseFrom({obj.get()});", depth + 1)

        file.content += self.indent("", depth + 1)
        file.content += self.indent(syntax.generate_comment("Initialize result variable"), depth + 1)
        file.content += self.indent(syntax.declare_variable(rows), depth + 1)

        for child in self._children:
            child.gen_code(syntax, file, rows, variable, depth + 1, type_map)

        file.content += self.indent(syntax.generate_return(rows), terminator=syntax.terminate_statement_delimiter(), depth=depth + 1)
        file.content += self.indent(syntax.block_end_delimiter(), depth)


class CodeNopNode(CodeGenImp):
    """
    Code generator node responsible for creating logical groups.
    """
    def __init__(self, table_root: bool, batch_table: bool):
        super().__init__()
        self._table_root = table_root
        self._batch_table = batch_table
        self._variable = None

    def get_variable(self):
        return self._variable

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):

        new_root = element
        if self._table_root and self.get_num_children() > 0:
            self._variable = Variable("common", "TableRow")
            file.content += self.indent(syntax.declare_variable(self._variable), depth)
            new_root = self._variable

        for child in self._children:
            child.gen_code(syntax, file, new_root, root_var, depth, type_map)

        if self._table_root and not self._batch_table:
            file.content += self.indent(syntax.generate_function_invocation(element, function_name="add", params=[self._variable]), depth)


class CodeGenNode(CodeGenImp):
    """
    Abstract node in the code generation tree.
    """
    def __init__(self, field: Field):
        super().__init__()
        self._field = field


class CodeGenBaseNode(CodeGenNode):
    """
    Code generation for atomic fields, i.e., it sets a particular (non-complex)
    table row to the value of the attribute, e.g.,

    tableRow.set("name", protoObj.getName());
    """
    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        # if self._field.is_timestamp:
        #     # FUTURE: Enhance logic to represent timestamps. This can be done
        #     # by using a 'general' mapper function for each field, prior to assigning
        #     # them to the bigquery table field.
        #     file.content += self.indent(element.set(self._field.get_bigquery_field_name(), f"Instant.ofEpochMilli({root_var.get()}).toString()"), depth)
        # else:
        #     file.content += self.indent(element.set(self._field.get_bigquery_field_name(), root_var.get()), depth)
        # FUTURE: Extend with timestamps
        file.content += self.indent(syntax.generate_function_invocation(element, function_name="set", params=[StaticValue(self._field.get_bigquery_field_name()), root_var]), depth)


class CodeGenConditionalNode(CodeGenNode):
    """
    Conditional code generation for a given field, i.e., node checks whether field value is
    available. Optionally, the node can throw an exception if the field is unavailable
    or establish a default value.

    if (protoObj.hasName()) {
        ..
    } else {
        throw new Exception("Required attribute 'name' not found on input);
        // or tableRow.set("name", defaultValue);
    }
    """
    def __init__(self, field: Field, throw_exception = False, default_value=None):
        super().__init__(field)
        self._throw_exception = throw_exception
        self._default_value = default_value

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        file.content += self.indent(syntax.generate_if_clause(condition=root_var.has(self._field)), terminator=syntax.block_start_delimiter(), depth=depth)

        for child in self._children:
             child.gen_code(syntax, file, element, root_var, depth + 1, type_map)

        if self._default_value is not None or self._throw_exception:

            file.content += self.indent(f"{syntax.block_end_delimiter()} else {syntax.block_start_delimiter()}", depth)

            # Fall back onto the fault value
            if self._default_value is not None:
                file.content += self.indent(syntax.generate_function_invocation(element, function_name="set", params=[StaticValue(self._field.get_bigquery_field_name()), StaticValue(self._default_value)]), depth)

            # Otherwise throw exception
            else:
                field_path = [x.field_name for x in root_var.getters] + [self._field.get_bigquery_field_name()]
                file.content += self.indent(syntax.generate_exception(exception_type="Exception", message=f'Required attribute \'{".".join(field_path)}\' not found on input.'), depth + 1)

        file.content += self.indent(syntax.block_end_delimiter(), depth)


class CodeGenGetFieldNode(CodeGenNode):
    """
    Code generation to apply a getter on the root variable, e.g.,

    street = protoObj.getAddress().getStreet();
    """
    def __init__(self, field: Field):
        super().__init__(field)

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        # FUTURE: root_var.push_invocation(Getter(self._field.field_name))
        root_var.push_getter(self._field)

        for child in self._children:
            child.gen_code(syntax, file, element, root_var, depth, type_map)

        # FUTURE: root_var.pop_invocation(Getter(self._field.field_name))
        root_var.pop_getter()


class CodeGenNestedNode(CodeGenNode):
    """
    Code generation for (nested) message fields. The node will create an intermediate
    tableCell and process the elements within the nested field. After completion
    the tableCell will be added to the tableRow.

    TableCell address = new TableCell();
    // recurse into children, e.g.,
    // address.set("street", protoObj.getAddress().getStreet())
    // ..
    tableRow.set("address", address);
    """
    def __init__(self, field: Field):
        super().__init__(field)
        self._declaration_required = not self._field.is_repeated_field

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        var = Variable(self._field.field_name, "TableCell")

        file.content += self.indent("", depth)
        file.content += self.indent(syntax.generate_comment(self._field.field_name), depth)
        file.content += self.indent(syntax.declare_variable(var), depth)

        for child in self._children:
            child.gen_code(syntax, file, var, root_var, depth, type_map)

        file.content += self.indent(syntax.generate_function_invocation(element, function_name="set", params=[StaticValue(self._field.get_bigquery_field_name()), var]), depth)


class CodeGenRepeatedNode(CodeGenNode):
    """
    Code generation for repeated fields. Repeated nodes are handled similar to the
    nested nodes, but construct an array of TableCells, e.g.,

    List<String> tag_cells = new LinkedList<>();

    for(ProtoTagObj tag: protoObj.getTagList()) {
        TableCell tag_cell = new TableCell();
        // recurse into children, e.g.,
        // tag_cell.set("code", ProtoTagObj.getCode())
        // ..
    }

    tableRow.set("tags", tag_cells)
    """
    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        list_var = ListVariable(f"{self._field.field_name}_cells", "LinkedList", "TableCell")
        var = Variable(f"{self._field.field_name}_cell", "TableCell")
        res = Variable(self._field.field_name, self._field.resolve_type(type_map))

        file.content += self.indent(syntax.declare_variable(list_var), depth)

        file.content += self.indent(f"for({res.type} {res.get()}: {root_var.get()}.{Variable.underscore_to_camelcase(f'get_{self._field.field_name}_list()')}) {syntax.block_start_delimiter()}", depth)  # nopep8
        file.content += self.indent(syntax.declare_variable(var), depth + 1)

        for child in self._children:
            child.gen_code(syntax, file, var, res, depth + 1, type_map)

        file.content += self.indent(syntax.generate_function_invocation(list_var, function_name="add", params=[var]), depth + 1)
        file.content += self.indent(syntax.block_end_delimiter(), depth)
        file.content += self.indent(syntax.generate_function_invocation(element, function_name="set", params=[StaticValue(self._field.get_bigquery_field_name()), list_var]), depth)


class CodeGenGetBatchNode(CodeGenNode):
    """
    Code generation for batched nodes, batched nodes are build up of a common and non-common
    section. The common section is applied to each non-common entry.
    """
    def __init__(self, field: Field, neighbour: CodeNopNode):
        super().__init__(field)
        self._neighbour = neighbour

    def gen_code(self, syntax: LanguageSyntax, file, element: Variable, root_var: Variable, depth: int, type_map: dict):
        root = Variable(self._field.field_name, self._field.resolve_type(type_map))
        row = Variable("row", "TableRow")

        file.content += self.indent(f"for({root.type} {root.get()}: {root_var.get()}.{Variable.underscore_to_camelcase(f'get_{self._field.field_name}_list()')}) {{", depth) # nopep8
        file.content += self.indent(syntax.declare_variable(row), depth + 1)

        for child in self._children:
            child.gen_code(syntax, file, row, root, depth + 1, type_map)

        variable = self._neighbour.get_variable()
        if variable is not None:
            # Merge contents of the batch row with the contents
            # of the shared row, if it exists.
            file.content += self.indent(f"for (String key: {variable.get()}.keySet()) {syntax.block_start_delimiter()}", depth + 1)
            file.content += self.indent(f"{row.get()}.set(key, {variable.get()}.get(key));", depth + 2)
            file.content += self.indent(syntax.block_end_delimiter(), depth + 1)

        file.content += self.indent(syntax.generate_function_invocation(element, function_name="add", params=[row]), depth + 1)
        file.content += self.indent(syntax.block_end_delimiter(), depth)




